%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass{entcs}
\usepackage{entcsmacro}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}

\usepackage[activate={true,nocompatibility},
            final,
            tracking=true,
            kerning=true,
            spacing=true,
            factor=1100,
            stretch=10,
            shrink=10]{microtype}
\microtypecontext{spacing=nonfrench}
\SetTracking{encoding={*},
             shape=sc}{10}

\usepackage{prftree}
\prfinterspace=1em
% \prflinepadbefore=1pt
% \prflinepadafter=3pt

\usepackage{environ}
\NewEnviron{proofalign*}{%
  \setlength{\abovedisplayskip}{0pt}%
  \setlength{\belowdisplayskip}{0pt}%
  \setlength{\abovedisplayshortskip}{0pt}%
  \setlength{\belowdisplayshortskip}{0pt}%
  \begin{proof}%
    \vspace{-\baselineskip}%
    \begin{align*}%
      \BODY%
    \end{align*}%
    \vspace{-2.75\baselineskip}\[\]%
  \end{proof}}
\NewEnviron{proofalignat*}[1]{%
  \setlength{\abovedisplayskip}{0pt}%
  \setlength{\belowdisplayskip}{0pt}%
  \setlength{\abovedisplayshortskip}{0pt}%
  \setlength{\belowdisplayshortskip}{0pt}%
  \begin{proof}%
    \vspace{-\baselineskip}%
    \begin{alignat*}{#1}%
      \BODY%
    \end{alignat*}%
    \vspace{-2.75\baselineskip}\[\]%
  \end{proof}}

% NOTE: Used to get "de Bruijn" to sort under "B"
\newcommand{\noopsort}[2]{#2}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\lambdabox}{\lambda^{\mkern-1mu\sq\mkern-2mu}}

\newcommand{\preop}[1]{\mathord{#1}-}
\newcommand{\postop}[1]{-\mathord{#1}}
\newcommand{\binop}[1]{-\mathord{#1}-}

\newcommand{\tsf}[1]{\textsf{\upshape{#1}}}
\newcommand{\stsf}[1]{\tsf{\small{#1}}}

\newcommand{\Set}{\tsf{Set}}
\renewcommand{\:}{\mathrel{:}}
\newcommand{\widecolon}{\mathrel{\rlap{$\mkern4.5mu:$}\hphantom{=}}}
\renewcommand{\r}{\mathrel{\rightarrow}}

\newcommand{\tyrule}[1]{\prftree[l]{${#1} \:\,$}}
\newcommand{\padtyrule}[1]{\prftree[l]{${#1} \widecolon\,$}}
\newcommand{\eqrule}[1]{\prftree[l]{${#1} =$}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Prelude


\newcommand{\id}{\operatorname{\tsf{id}}}
\newcommand{\comp}{\mathrel{\circ}}

\newcommand{\projI}{\operatorname{\tsf{proj}_{\stsf{1}}}}
\newcommand{\projZ}{\operatorname{\tsf{proj}_{\stsf{2}}}}
\newcommand{\comma}{\mathbin{,}}
\renewcommand{\;}{\mathbin{;}}

\let\oldforall\forall
\renewcommand{\forall}{\oldforall\,}

\let\oldexists\exists
\renewcommand{\exists}{\oldexists\,}

\newcommand{\0}{\varnothing}

\newcommand{\zero}{\operatorname{\tsf{zero}}}
\newcommand{\suc}{\operatorname{\tsf{suc}}}


\newcommand{\List}{\operatorname{\tsf{List}}}
\newcommand{\All}{\operatorname{\tsf{All}}}

\renewcommand{\geq}{\mathrel{\supseteq}}

\newcommand{\done}{\operatorname{\tsf{done}}}
\newcommand{\wk}{\operatorname{\tsf{wk}}}
\newcommand{\lift}{\operatorname{\tsf{lift}}}

\newcommand{\infe}{\operatorname{\tsf{inf}_{\stsf{e}}}}
\newcommand{\ide}{\operatorname{\tsf{id}_{\stsf{e}}}}
\newcommand{\compe}{\mathrel{\circ_{\mkern-1mu\stsf{e}}}}

\newcommand{\lookupe}{\operatorname{\tsf{lookup}_{\stsf{e}}}}

\newcommand{\ListZ}{\operatorname{\tsf{List}^{\stsf{2}}}}

\newcommand{\geqZ}{\mathrel{\supseteq^{\stsf{2}}}}

\newcommand{\mwkZ}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{wk}^{\stsf{2}}}}
\newcommand{\wkZ}{\operatorname{\tsf{wk}^{\stsf{2}}}}

\newcommand{\ideZ}{\operatorname{\tsf{id}_{\stsf{e}}^{\stsf{2}}}}
\newcommand{\compeZ}{\mathrel{\circ_{\mkern-1mu\stsf{e}}^{\stsf{2}}}}

\newcommand{\mlookupeZ}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{lookup}_{\stsf{e}}^{\stsf{2}}}}
\newcommand{\lookupeZ}{\operatorname{\tsf{lookup}_{\stsf{r}}^{\stsf{e}}}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Syntax

\newcommand{\Tp}{\operatorname{\tsf{Tp}}}

\newcommand{\tvar}{\operatorname{^{\stsf{tv}\mkern-1mu}}}
\newcommand{\R}{\Rightarrow}
\newcommand{\sq}{\Box}

\newcommand{\Cx}{\tsf{Cx}}

\newcommand{\D}{\mathcal{D}}
\newcommand{\E}{\mathcal{E}}

\renewcommand{\e}{\mathrel{\vdash}}

\newcommand{\mvar}{\operatorname{^{\stsf{mv}\mkern-1mu}}}
\newcommand{\var}{\operatorname{^{\stsf{v}\mkern-1mu}}}
\newcommand{\lam}{\operatorname{\lambda}}
\newcommand{\app}{\mathbin{\$}}
\newcommand{\quo}[1]{\mathopen{\ulcorner}{#1}\mathclose{\urcorner}}
\newcommand{\unq}[1]{\mathopen{\llcorner}{#1}\mathclose{\lrcorner}\,}

\newcommand{\enm}{\mathrel{\vdash_{\mkern-2mu\stsf{nm}}}}
\newcommand{\ent}{\mathrel{\vdash_{\mkern-2mu\stsf{nt}}}}

\newcommand{\nt}{\operatorname{^{\stsf{nt}\mkern-1mu}}}

\newcommand{\embnm}{\operatorname{\tsf{emb}_{\stsf{nm}}}}
\newcommand{\embnt}{\operatorname{\tsf{emb}_{\stsf{nt}}}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Renaming


\newcommand{\mren}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{ren}}}
\newcommand{\ren}{\operatorname{\tsf{ren}}}

\newcommand{\mrennm}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{ren}_{\stsf{nm}}}}
\newcommand{\mrennt}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{ren}_{\stsf{nt}}}}
\newcommand{\rennm}{\operatorname{\tsf{ren}_{\stsf{nm}}}}
\newcommand{\rennt}{\operatorname{\tsf{ren}_{\stsf{nt}}}}

\newcommand{\rennmZ}{\operatorname{\tsf{ren}_{\stsf{nm}}^{\stsf{2}}}}
\newcommand{\renntZ}{\operatorname{\tsf{ren}_{\stsf{nt}}^{\stsf{2}}}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Substitution


\newcommand{\es}{\mathrel{\vdash^{\mkern-2mu\star}}}

\newcommand{\mrens}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{ren}^{\mkern-2mu\star}}}
\newcommand{\rens}{\operatorname{\tsf{ren}^{\mkern-2mu\star}}}

\newcommand{\mwks}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{wk}_{\stsf{s}}}}
\newcommand{\wks}{\operatorname{\tsf{wk}_{\stsf{s}}}}
\newcommand{\mlifts}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{lift}_{\stsf{s}}}}
\newcommand{\lifts}{\operatorname{\tsf{lift}_{\stsf{s}}}}

\newcommand{\mids}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{id}_{\stsf{s}}}}
\newcommand{\ids}{\operatorname{\tsf{id}_{\stsf{s}}}}

\newcommand{\lookups}{\operatorname{\tsf{lookup}_{\stsf{s}}}}
\newcommand{\msub}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{sub}}}
\newcommand{\sub}{\operatorname{\tsf{sub}}}



%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Semantics


\newcommand{\K}{\mathfrak{K}}
\newcommand{\M}{\mathfrak{M}}
\newcommand{\W}{\mathcal{W}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\ida}{\operatorname{\tsf{id}_{\stsf{a}}}}
\newcommand{\compa}{\mathrel{\circ_{\stsf{a}}}}
\newcommand{\accv}{\operatorname{\tsf{acc}_{\stsf{v}}}}
\newcommand{\peek}[1]{\mathopen{\lfloor}{#1}\mathclose{\rfloor}}
\newcommand{\peeka}[1]{\mathopen{\lfloor}{#1}\mathclose{\rfloor_{\mkern-2mu\stsf{a}}}}

\newcommand{\mpeek}[1]{\mathopen{^{\stsf{m}\mkern-3mu}\lfloor}{#1}\mathclose{\rfloor}}
\newcommand{\mpeeka}[1]{\mathopen{^{\stsf{m}\mkern-3mu}\lfloor}{#1}\mathclose{\rfloor_{\mkern-2mu\stsf{a}}}}

\newcommand{\ee}{\mathrel{\Vdash}}
\newcommand{\kee}{\mathrel{^{\stsf{k}\mkern-6mu}\Vdash}}
\newcommand{\mee}{\mathrel{^{\stsf{m}\mkern-6mu}\Vdash}}
\newcommand{\mkee}{\mathrel{^{\stsf{mk}\mkern-6mu}\Vdash}}

\newcommand{\ees}{\mathrel{\Vdash^{\mkern-2mu\star}}}
\newcommand{\kees}{\mathrel{^{\stsf{k}\mkern-6mu}\Vdash^{\mkern-2mu\star}}}
\newcommand{\mees}{\mathrel{^{\stsf{m}\mkern-6mu}\Vdash^{\mkern-2mu\star}}}
\newcommand{\mkees}{\mathrel{^{\stsf{mk}\mkern-6mu}\Vdash^{\mkern-2mu\star}}}
\newcommand{\syn}{\operatorname{\tsf{syn}}}
\newcommand{\sem}{\operatorname{\tsf{sem}}}

\newcommand{\eeq}{\mathrel{\vDash}}

\newcommand{\acc}{\operatorname{\tsf{acc}}}
\newcommand{\kacc}{\operatorname{^{\stsf{k}\mkern-2mu}\tsf{acc}}}
\newcommand{\mkacc}{\operatorname{^{\stsf{mk}\mkern-2mu}\tsf{acc}}}
\newcommand{\kaccs}{\operatorname{^{\stsf{k}\mkern-2mu}\tsf{acc}^{\star}}}
\newcommand{\mkaccs}{\operatorname{^{\stsf{mk}\mkern-2mu}\tsf{acc}^{\star}}}

\newcommand{\return}{\operatorname{\tsf{return}}}
\newcommand{\bind}{\operatorname{\tsf{bind}}}

\newcommand{\reflect}{\uparrow\mkern-4mu}
\newcommand{\menv}{\operatorname{^{\stsf{m}\mkern-6mu}\rho}}
\newcommand{\env}{\operatorname{\rho}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Completeness


\newcommand{\Mu}{\mathfrak{M}_{\stsf{u}}}

\newcommand{\reifyu}{\downarrow_{\stsf{u}}\mkern-4mu}
\newcommand{\reflectu}{\uparrow_{\mkern-2mu\stsf{u}}\mkern-4mu}

\newcommand{\mkide}{\operatorname{^{\stsf{mk}\mkern-2mu}\tsf{id}_{\rho}}}
\newcommand{\kide}{\operatorname{^{\stsf{k}\mkern-2mu}\tsf{id}_{\rho}}}
\newcommand{\reify}{\downarrow\mkern-4mu}

\newcommand{\nm}{\operatorname{\tsf{nm}}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Examples


\newcommand{\mvO}{\operatorname{^{\stsf{mv}\mkern-1mu}\tsf{0}}}
\newcommand{\mvI}{\operatorname{^{\stsf{mv}\mkern-1mu}\tsf{1}}}
\newcommand{\mvZ}{\operatorname{^{\stsf{mv}\mkern-1mu}\tsf{2}}}
\newcommand{\vO}{\operatorname{^{\stsf{v}\mkern-1mu}\tsf{0}}}
\newcommand{\vI}{\operatorname{^{\stsf{v}\mkern-1mu}\tsf{1}}}
\newcommand{\vZ}{\operatorname{^{\stsf{v}\mkern-1mu}\tsf{2}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\def\lastname{Bak}

\begin{document}

\begin{frontmatter}


\title{Introspective Kripke models\\and normalisation-by-evaluation\\for the $\lambdabox$-calculus}

\author{Mi\"{e}tek Bak\thanksref{email}}

\address{Least Fixed Ltd, Cambridge, UK}

\thanks[email]{\href{mailto:mietek@bak.io}{\textnormal{\texttt{mietek@bak.io}}}}


\begin{abstract}
  We consider the $\lambdabox$-calculus, an extension of the simply typed $\lambda$-calculus with a \emph{type of quoted programs} that corresponds to the $\sq$ connective of the modal logic S4.  We present a novel class of \emph{introspective Kripke models,} constructed in continuation-passing style, and prove the syntax of the $\lambdabox$-calculus sound and complete with respect to these models.  We fully formalise the arguments in \textsc{Agda}, a dependently typed total functional programming language based on intensional type theory.  The composition of our soundness and completeness proofs is an \textsc{Agda} program that performs normalisation-by-evaluation for the $\lambdabox$-calculus.
\end{abstract}

\begin{keyword}
  constructive logic, continuation-passing style, completeness, Curry-Howard correspondence, intensionality, intuitionistic logic, Kripke semantics, meta-programming, modal logic S4, normalisation-by-evaluation, quotation, self-interpretation, typed $\lambda$-calculus
\end{keyword}

\end{frontmatter}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introduction}


I'd like to have a total functional programming language that works like Lisp; that is, a language that allows programs to be quoted, inspected, and evaluated, in which types are propositions and programs are proofs.  Some people have been using the modal logic S4 for similar purposes.  I quickly found a reasonable $\lambda$-calculus based on S4, that is, the $\lambdabox$-calculus, and I set out to write an interpreter for it.
\begin{gather*}
  \prftree{\Delta \ni A}
          {\Delta; \Gamma \e A}
  \qquad
  \prftree{\Delta; \0 \e A}
          {\Delta; \Gamma \e \sq A}
  \qquad
  \prftree{\Delta; \Gamma \e \sq A}{\Delta, A; \Gamma \e C}
          {\Delta; \Gamma \e C}
\end{gather*}
It's well-known that if we prove a language sound and complete with respect to some class of models, then an interpreter falls out --- as long as the proofs are constructive.  Unfortunately, all I could find was classical proofs of completeness for S4, and so I decided to do the proofs myself.

It's also well-known how to prove STLC sound and complete with respect to intuitionistic Kripke semantics.  Since the $\lambdabox$-calculus is an extension of STLC, I thought it should be simple to extend intuitionistic Kripke semantics and obtain the desired proofs.  Famous last words!  Eventually, I realised that the interpretation of $\sq A$ should be a syntactically-justified interpretation of $A$; that is, a pair consisting of a derivation of $A$ and an interpretation of $A$.
\begin{gather*}
  \Delta; \Gamma \ee \sq A\,=\,\forall \Delta' \geq \Delta, \Gamma' \geq \Gamma.\ \Delta'; \Gamma' \mee A\\[0.5\baselineskip]
  \Delta; \Gamma \mee A\,=\,\Delta; \0 \e A\,\times\,\Delta; \Gamma \ee A
\end{gather*}
This puts the syntax in the semantics --- peeks beneath the veil sooner than expected.  We can still keep the abstraction of a Kripke semantics, as long as we can discard it when we need to.  We define an \emph{introspective Kripke model} as a tuple with a set of worlds, $\W$, and other things.
\begin{gather*}
  \M\,=\,\langle\,\W,\,\V,\,\binop{\ge},\,\ida,\,\binop{\compa},\,\accv,\,\peek{-},\,\peeka{-}\,\rangle
\end{gather*}
Now, we can try to write the interpretation of $\sq A$ using the model.
\begin{gather*}
  \M\,|\,w \ee \sq A\,=\,\forall w' \ge w.\ \M\,|\,w' \mee A\\[0.5\baselineskip]
  \M\,|\,w \mee A\,=\,\mpeek{w}; \0 \e A\,\times\,\M\,|\,w \ee A
\end{gather*}
However, adding this interpretation to intuitionistic Kripke semantics allows us to prove soundness, but not completeness.  The problem with proving completeness with respect to the modified semantics is similar to the problem with proving completeness of full STLC, with disjunction and the empty type.  Some people have already come up with a solution to that, which is a CPS transformation of the semantics.
\begin{gather*}
  \M\,|\,w \ee \sq A\,=\,\forall w' \ge w.\ \M\,|\,w' \mkee A\\[0.5\baselineskip]
  \M\,|\,w \mkee A\,=\,\mpeek{w}; \0 \e A\,\times\,\M\,|\,w \kee A\\[0.5\baselineskip]
  \M\,|\,w \kee A\,=\,\forall C, w' \ge w.\ \prftree{\forall w'' \ge w'.\ \prftree{\M\,|\,w'' \ee A}{\lfloor w'' \rfloor \enm C}}{\lfloor w' \rfloor \enm C}
\end{gather*}
It turns out that CPS transforming the modified semantics allows us to prove soundness and completeness, and so, to write an interpreter for the $\lambdabox$-calculus.  I've done that now, and I think this interpreter can be used to decide $\beta\eta$-equivalence according to the following convertibility relation, but I haven't managed to prove this yet.
\begin{gather*}
  \Delta; \Gamma \eeq A\,=\,\forall \M, w.\ \prftree{\M\,|\,w \mkees \Delta}{\M\,|\,w \kees \Gamma}{\M\,|\,w \kee A}\\[\baselineskip]
  \tyrule{\reflect{-}}{\Delta; \Gamma \e A}{\Delta; \Gamma \eeq A}
  \qquad
  \tyrule{\reify{-}}{\Delta; \Gamma \eeq A}{\Delta; \Gamma \enm A}
\end{gather*}
To prove completeness, we need a canonical model.  We first prove soundness and completeness with respect to this canonical model, and then use that to prove completeness proper.
\begin{gather*}
  \Mu\,=\,\langle\,\Cx,\,(\Delta; \Gamma)\,x \mapsto \Delta; \Gamma \enm \tvar x,\,\binop{\geqZ},\,\ideZ,\,\binop{\compeZ},\,\rennmZ,\,\id,\,\id\,\rangle\\[0.5\baselineskip]
  \tyrule{\reflectu{-}}{\Delta; \Gamma \ent A}{\Delta; \Gamma \kee A}
  \qquad
  \tyrule{\reifyu{-}}{\Delta; \Gamma \kee A}{\Delta; \Gamma \enm A}
\end{gather*}
%
%
% Some say that in \textsc{Lisp}, code is data.  Instead, we say that code may be $\quot$ed to become data, and data may be $\eval$uated to become code.


% McCarthy \emph{et al.} \cite{McCarthyAEHL62}.  Turner \cite{Turner04}.  Sheard \cite{Sheard01}.  Pfenning and Davies \cite{PfenningD01}.  Davies and Pfenning \cite{DaviesP01}.  C.~Coquand \cite{Coquand02}.  Norell \cite{Norell07}.  Stump \cite{Stump16}.
%
%
% %.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.
%
%
% \subsection*{Related work}
%
% Syntax.  Bierman and de~Paiva \cite{BiermanP00}.  Dyckhoff \cite{Dyckhoff16}.  Girard \emph{et al.} \cite{GirardTL89}.  \cite{Kovacs17}.
%
% Normalisation-by-evaluation.  Martin-L\"{o}f \cite{MartinLof75}.  Berger and Schwichtenberg \cite{BergerS91}.  C.~Coquand \cite{Coquand93}.  Dybjer and Filinski \cite{DybjerF02}.  Abel \cite{Abel13}.  Wadler \cite{Wadler15}.
%
% Semantics.  Ili\'{c} \cite{Ilic13}.  Danvy \cite{Danvy96}.
%
% Kripke \cite{Kripke65}.  Ili\'{c} \cite{Ilic13}.  Iemhoff \cite{Iemhoff01}.  Boolos \cite{Boolos94}.  T.~Coquand and Dybjer \cite{CoquandD97}.  Gabbay and Nanevski \cite{GabbayN13}.  Art\"{e}mov \cite{Artemov01}.  G\"{o}del \cite{Godel33}.  McKinsey and Tarski \cite{McKinseyT48}.
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% \section{Syntax}
%
% We begin by formalising the syntax of the $\lambdabox$-calculus.
%
%
% \begin{definition}
%   Types.
%
% $\T$ $\ast$ $\binop{\R}$ $\sq$
% \end{definition}
%
%
% \begin{definition}
%   Contexts.
%
% $\C$ $\CZ$ $\O$
% \end{definition}
%
%
% \begin{definition}
%   Variables.  De Bruijn \cite{DeBruijn72}.
%
% $\binop{\ni}$ $\zero$ $\suc$
% \end{definition}
%
%
% \begin{definition}
%   Syntactic entailment.  Unlike Pfenning and Davies \cite{PfenningD01}, we define only the well-typed terms.  Altenkirch and Reus \cite{AltenkirchR99}.
%
%
%
% $\binop{\e}$ $\mvar$ $\var$ $\lam$ $\binop{\app}$ $\quo{-}$ $\unq{-}{-}$ $\mvO$ $\mvI$ $\mvZ$ $\vO$ $\vI$ $\vZ$
% \end{definition}
%
%
% \begin{definition}
%   Normal and neutral forms.  Altenkirch \cite{Altenkirch93}.  Joachimski and Matthes \cite{JoachimskiM03}.
%
% $\binop{\enm}$ $\binop{\ent}$ $\ne$ $\embnf$ $\embne$
% \end{definition}
%
%
% \begin{definition}
%   Convertibility.
%
% $\binop{\conv}$
% \end{definition}
%
%
% %.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.
%
%
% \subsection*{Renaming}
% XXX
%
%
% \begin{definition}
%   Order-preserving embeddings.  Altenkirch, Hofmann, and Streicher \cite{AltenkirchHS95}.  McBride \cite{McBride05}.  Chapman \cite{Chapman09}.
%
% $\binop{\geq}$ $\binop{\geqZ}$ $\doner$ $\wkr$ $\liftr$
% \end{definition}
%
%
% $\mwkrZ$ $\wkrZ$ $\infr$ $\ide$ $\idrZ$ $\binop{\compr}$ $\lookupr$ $\mlookuprZ$ $\lookuprZ$
%
%
% \begin{lemma}[Renaming]
%
% $\mren$ $\ren$ $\renZ$ $\mrennf$ $\mrenne$ $\rennf$ $\renne$ $\rennfZ$ $\renneZ$
% \begin{proof}
%   XXX
% \end{proof}
% \end{lemma}
%
%
% %.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.
%
%
% \subsection*{Substitution}
% XXX
%
%
% \begin{definition}
%   Simultaneous substitutions.
%
% XXX
% \end{definition}
%
%
% \begin{lemma}[Substitution]
%
% XXX
% \begin{proof}
%   XXX
% \end{proof}
% \end{lemma}
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% \section{Semantics}
%
%
%
% \begin{definition}
%   Introspective Kripke models.
%
% XXX
% \end{definition}
%
%
% \begin{definition}
%   Values.
%   \begin{align*}
%     & \binop{\ee} \: \W \r \T \r \Set\\[0.5\baselineskip]
%     &
%   \end{align*}
% \end{definition}
%
%
% \begin{definition}
%   Environments.  XXX.
%   \begin{align*}
%     & \binop{\dees} \: \W \r \C \r \Set\\
%     & w \dees \Xi = \All\,(w \preop{\dee})\,\Xi
%   \end{align*}
%   Justified environments.  XXX.
%   \begin{align*}
%     & \binop{\mdees} \: \W \r \C \r \Set\\
%     & w \mdees \Xi = \All\,(w \preop{\mdee})\,\Xi
%   \end{align*}
% \end{definition}
%
%
% \begin{lemma}
%   Projections.  XXX.
%   \begin{align*}
%     & \tyrule{\syn}{w \mdees \Xi}
%                    {\mpeek w \; \O \es \Xi}
%       \qquad
%       \tyrule{\sem}{w \mdees \Xi}
%                    {w \dees \Xi}
%   \end{align*}
% \end{lemma}
%
%
% \begin{definition}
%   Semantic entailment.  XXX.
%   \begin{align*}
%     & \binop{\eeq} \: \CZ \r \T \r \Set\\
%     & \eqrule{\Delta \; \Gamma \eeq A}{w \mdees \Delta}{w \dees \Gamma}
%                                       {w \dee A}
%   \end{align*}
% \end{definition}
%
%
% \begin{lemma}
%   Accessibility.  XXX.
%   \begin{align*}
%     & \tyrule{\acc}{w' \ge w}{w \ee A}
%                    {w' \ee A}
%       \qquad
%       \tyrule{\dacc}{w' \ge w}{w \dee A}
%                     {w' \dee A}
%   \end{align*}\vspace{-1.5\baselineskip}
%   \begin{align*}
%     & \tyrule{\mdacc}{w' \ge w}{w \mdee A'}
%                      {w' \mdee A}
%   \end{align*}
%   \begin{proofalign*}
%     & \acc = \dots\\[0.5\baselineskip]
%     & \dacc = \dots\\[0.5\baselineskip]
%     & \mdacc = \dots
%   \end{proofalign*}
% \end{lemma}
%
%
% \begin{theorem}[Soundness]
%   XXX.
%   \begin{align*}
%     & \tyrule{\reflect{-}}{\Delta \; \Gamma \e A}
%                           {\Delta \; \Gamma \eeq A}
%   \end{align*}
%   \begin{proofalignat*}{2}
%     & \reflect{\mvar i}    &\,\menv \env = \dots\\
%     & \reflect{\var i}     &\,\menv \env = \dots\\
%     & \reflect{\lam M}     &\,\menv \env = \dots\\
%     & \reflect{M \app N}   &\,\menv \env = \dots\\
%     & \reflect{\quo{M}}    &\,\menv \env = \dots\\
%     & \reflect{\unq{M}{N}} &\,\menv \env = \dots
%   \end{proofalignat*}
% \end{theorem}
%
%
% %.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.
%
%
% \subsection*{Canonical model}
%
%
% \begin{definition}
%   Canonical model.  XXX.
%   \begin{align*}
%     & \canon \widecolon \mathfrak{M}\\
%     & \canon =
%       \begin{cases}
%         \mathcal{W}    &\mkern-15mu = \CZ\\
%         \mathcal{G}    &\mkern-15mu = \postop{\enm \ast}\\
%         \binop{\ge}    &\mkern-15mu = \binop{\geqZ}\\
%         \ida           &\mkern-15mu = \idrZ\\
%         \binop{\compa} &\mkern-15mu = \binop{\comprZ}\\
%         \accG          &\mkern-15mu = \rennfZ\\
%         \peekZ         &\mkern-15mu = \id\\
%         \peekaZ        &\mkern-15mu = \id
%       \end{cases}
%   \end{align*}
% \end{definition}
%
%
% \begin{lemma}
%   Canonical reification and reflection.  XXX.
%   \begin{align*}
%     & \tyrule{\reifyu}{\Delta \; \Gamma \dee A}
%                       {\Delta \; \Gamma \enm A}
%       \qquad
%       \tyrule{\reflectu{-}}{\Delta \; \Gamma \ent A}
%                            {\Delta \; \Gamma \dee A}
%   \end{align*}
%   \begin{proof}
%     XXX.
%     \begin{alignat*}{4}
%       & \reifyu      &&\,\{\ast\}   &&\,\kappa &&= \kappa \idrZ\,(\lambda\,\eta\,M \r M)\\
%       & \reifyu      &&\,\{A \R B\} &&\,\kappa &&= \kappa \idrZ\,(\lambda\,\eta\,f \r \lam\,(\reifyu\,(f\,(\wkrZ \idrZ)\,\reflectu{\var \zero}))\\
%   %    & \reifyu      &&\,\{A \wedge B\}  &&\,\kappa &&= \kappa \idrZ\,(\lambda\,\eta\,p \r \reifyu\,(\projI\,p) \comma \reifyu\,(\projZ\, p))\\
%       & \reifyu      &&\,\{\sq A\}  &&\,\kappa &&= \kappa \idrZ\,(\lambda\,\eta\,f \r \quo{\projI\,(f \idrZ)})
%     \end{alignat*}
%     XXX.
%     \begin{alignat*}{3}
%       & \reflectu{M} &&\,\{\ast\}   && = \return\,(\ne M)\\
%       & \reflectu{M} &&\,\{A \R B\} && = \return\,(\lambda\,\eta\,\kappa \r \reflectu{\renneZ \eta\,M \app \reifyu \kappa})\\
%       & \reflectu{M} &&\,\{\sq A\}  && = \lambda\,\eta\,f \r \ne\,(\unq{\renneZ \eta\,M}\,(f\,(\mwkrZ \idrZ)\,(\lambda\,\eta' \r\\
%       &              &&             && \qquad \mvar\,(\mlookuprZ \eta' \zero) \comma \reflectu{\mvar\,(\mlookuprZ \eta' \zero)})))
%     \end{alignat*}
%     \vspace{-4.25\baselineskip}\[\]%
%   \end{proof}
% \end{lemma}
%
%
% \begin{lemma}
%   Justified environment of reflected modal variables.  Environment of reflected variables.  XXX.
%   \begin{align*}
%     & \mide \: \Delta \; \Gamma \mdees \Delta
%       \qquad
%       \ide \: \Delta \; \Gamma \dees \Gamma
%   \end{align*}
% \end{lemma}
%
% \begin{theorem}[Completeness]
%   XXX.
%   \begin{align*}
%     & \tyrule{\reify}{\Delta \; \Gamma \eeq A}
%                      {\Delta \; \Gamma \enm A}
%   \end{align*}
%   \begin{proofalign*}
%     & \reify \mathfrak{a} = \reifyu\,(\mathfrak{a} \mide \ide)
%   \end{proofalign*}
% \end{theorem}
%
%
% \begin{corollary}[Normalisation]
%   We obtain a normalisation program as composition of the soundness and completeness proofs.
%   \begin{align*}
%     & \tyrule{\nm}{\Delta \; \Gamma \e A}
%                   {\Delta \; \Gamma \enm A}
%   \end{align*}
%   \begin{proofalign*}
%     & \nm = \reify \comp \reflect{-}
%   \end{proofalign*}
% \end{corollary}
%
%
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
% \section{Conclusion}
%
% I presented a class of introspective Kripke models, and gave a fully formalised proof of soundness and completeness of the syntax of the $\lambdabox$-calculus with respect to these models.
%
% As far as I know, this work contains the first published constructive proof of completeness for a $\lambda$-calculus that corresponds to the modal logic S4.  The proofs given by Ono \cite{Ono77}, Bo\v{z}i\'{c} and Do\v{s}en \cite{BozicD84}, Fischer Servi \cite{FischerServi84}, Ewald \cite{Ewald86}, Plotkin and Stirling \cite{PlotkinS86}, Wijesekera \cite{Wijesekera90}, Simpson \cite{Simpson94}, and Alechina \emph{et al.} \cite{AlechinaMPR01} all proceed by contradiction.
%
% Additionally, I think that the normalisation-by-evaluation program presented in this work is the first published direct proof of weak normalisation for the $\lambdabox$-calculus.  A proof of strong normalisation for \textbf{CMTT}, which is an extension of the $\lambdabox$-calculus, has been given by Nanevski, Pfenning, and Pientka \cite{NanevskiPP08}.
%
% The syntax of \textbf{CMTT} is also sound and complete with respect to introspective Kripke models, given an appropriately amended definition of values.  Showing this remains future work.
%
%
% %.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.
%
%
% \subsection*{Self-interpretation}
%
% Self-interpretation for a total functional programming language, almost universally believed to be impossible, has been demonstrated for System $\textbf{F}_{\omega}$ by Brown and Palsberg \cite{BrownP16}, but not without controversy.  Bauer \cite{Bauer16} gives a precise definition of a Brown-Palsberg self-intepreter, which we adapt here.
%
% We write $\mathfrak{G}(M)$ for the G\"{o}del code of a program $M$, which is a suitable encoding of $M$ by a natural number, and $\underline{n}$ for the numeral that represents $n \in \mathbb{N}$.
%
% \begin{definition}\label{normality}
%   A quotation operator, \tyrule{\quo{-}}{\O \e A}{\Delta \; \Gamma \e \sq A}, is \emph{normal} when $\quo{M}$ is $\beta$-normal for all $M \: \O \e A$, and \emph{acceptable} when there is a G\"{o}del-coding function, $\code \: \Delta \; \Gamma \e \sq A \R \underline{\mathbb{N}}$, such that $\code \app \quo{M} = \underline{\smash{\mathfrak{G}(M)}}$ for all $M \: \O \e A$.
% \end{definition}
%
% \begin{definition}
%   A \emph{self-interpreter} is an evaluation function, $\eval \: \Delta \; \Gamma \e \sq A \R A$, such that $\eval \app \quo{M} \bconv M$ for all $M \: \O \e A$.
% \end{definition}
%
% \begin{theorem}
%   The $\lambdabox$-calculus has a self-interpreter.
%   \begin{proofalign*}
%     & \eval \widecolon \Delta \; \Gamma \e \sq A \R A\\
%     & \eval = \lam (\unq{\vO}{\mvO})
%   \end{proofalign*}
% \end{theorem}
%
% It should come as no surprise that the $\lambdabox$-calculus has a self-interpreter, since $\Taxiom = \sq A \R A$ is an axiom of S4.  Moreover, a similar self-interpreter is necessarily present in every $\lambda$-calculus that corresponds to a modal logic in which $\Taxiom$ holds, such as \textbf{CMTT} \cite{NanevskiPP08}, or the intensional $\lambda$-calculus of Art\"{e}mov and Bonelli \cite{ArtemovB07}.
%
% Bauer's statement of normality is a formal expression of the slogan \emph{`code is data',} while acceptability is representative of intensional code analysis: the ability of meta-programs to inspect and deconstruct quoted programs.  In the \textsc{Lisp} programming language, due to McCarthy \emph{et al.} \cite{McCarthyAEHL62}, the \texttt{quote} special form is both normal and acceptable.  In the $\lambdabox$-calculus, the quotation introduction rule, $\quo{-}$, is normal, but is not acceptable: the definition of $\lambdabox$-convertibility does forbid normalisation under $\quo{-}$, but there is no method by which quoted programs could be inspected, deconstructed, or tested for equality.
%
% The Kripke axiom, $\Kaxiom = \sq (A \R B) \R \sq A \R \sq B$, also known as the distributivity axiom, is sometimes referred to as `normality', since it holds in every normal modal logic.  To avoid confusion, we will only refer to the Kripke axiom as $\Kaxiom$.
%
% Bauer considers amending the definition of a self-interpreter to require a distribution function, $\dist \: \Delta \; \Gamma \e \Kaxiom$, such that $\dist \app \quo{M} \app \quo{N} \bconv \quo{M \app N}$ for all $M \: \Delta \; \Gamma \e A \R B$, $N \: \Delta \; \Gamma \e A$.  Since $\Kaxiom$ is an axiom of S4, the $\lambdabox$-calculus has $\dist = \lam (\lam (\unq{\vI}{(\unq{\vO}{\quo{\mvI \app \mvO}})}))$, and continues to enjoy self-interpretation under the amended definition.
%
% Intensional code analysis, identified by Sheard \cite{Sheard01} as a research challenge in meta-programming, has been investigated in a nominal setting by Nanevski \cite{Nanevski02,Nanevski04}, and as part of a dependently typed $\lambda$-calculus for the logical framework by Pientka and Abel \cite{PientkaA15}.  I think that further investigation of \textbf{LP} \cite{Artemov01} will offer additional insight into this challenge.


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.


\subsection*{Acknowledgements}

The author is deeply grateful to Andreas Abel, Guillaume Allais, Ahmad Salim Al-Sibahi, Roy Dyckhoff, Michael Gabbay, Paolo Giarrusso, Tom Jack, Roman Kireev, Jerzy Marcinkowski, Darryl McAdams, Conor McBride, Dominic Orchard, Maciej Pir\'{o}g, Ida Szubert, Tarmo Uustalu, Andrea Vezzosi, and Tomasz Wierzbicki, for many fruitful discussions over the years.

Furthermore, the author thanks Sergei Artemov, Andrej Bauer, Jacques Carette, Danko Ilik, Alex Kavvos, Jon Sterling, the anonymous reviewers, and the participants of IMLA'17, for comments that helped improve this work.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% TODO: Remove this!
\subsection*{Citations}

Abel (2013) \cite{Abel2013}.
Alechina \emph{et~al.} (2001) \cite{AlechinaMPR2001}.
Altenkirch (1993) \cite{Altenkirch1993}.
Altenkirch, Hofmann, and Streicher (1995) \cite{AltenkirchHS1995}.
Altenkirch and Reus (1999) \cite{AltenkirchR1999}.
Artemov (2001) \cite{Artemov2001}.
Artemov and Bonelli (2007) \cite{ArtemovB2007}.
Bauer (2016) \cite{Bauer2016}.
Berger and Schwichtenberg (1991) \cite{BergerS1991}.
Bierman and de~Paiva (2000) \cite{BiermanP2000}.
Boolos (1994) \cite{Boolos1994}.
Bo\v{z}i\'{c} and Do\v{s}en (1984) \cite{BozicD1984}.
Brown and Palsberg (2016) \cite{BrownP2016}.
Chapman (2009) \cite{Chapman2009}.
C.~Coquand (1993) \cite{Coquand1993}.
C.~Coquand (2002) \cite{Coquand2002}.
T.~Coquand and Dybjer (1997) \cite{CoquandD1997}.
Danvy (1996) \cite{Danvy1996}.
Danvy, Keller, and Puech (2014) \cite{DanvyKP2014}.
Davies and Pfenning (2001) \cite{DaviesP2001}.
de~Bruijn (1972) \cite{DeBruijn1972}.
Dybjer and Filinski (2002) \cite{DybjerF2002}.
Dyckhoff (2016) \cite{Dyckhoff2016}.
Ewald (1986) \cite{Ewald1986}.
Fischer Servi (1984) \cite{FischerServi1984}.
Fitting (2005) \cite{Fitting2005}.
Gabbay and Nanevski (2013) \cite{GabbayN2013}.
Girard \emph{et~al.} (1989) \cite{GirardTL1989}.
G\"{o}del (1933) \cite{Goedel1933}.
Iemhoff (2001) \cite{Iemhoff2001}.
Ilik (2010) \cite{Ilik2010}.
Ilik (2013) \cite{Ilik2013}.
Joachimski and Matthes (2003) \cite{JoachimskiM2003}.
Kovacs (2017) \cite{Kovacs2017}.
Kripke (1965) \cite{Kripke1965}.
Lindley (2005) \cite{Lindley2005}.
Martin-L\"{o}f (1975) \cite{MartinLoef1975}.
McBride (2005) \cite{McBride2005}.
McCarthy \emph{et~al.} (1962) \cite{McCarthyAEHL1962}.
McKinsey and Tarski (1948) \cite{McKinseyT1948}.
Meyer and Wand (1985) \cite{MeyerW1985}.
Mkrtychev (1997) \cite{Mkrtychev1997}.
Nanevski (2002) \cite{Nanevski2002}.
Nanevski (2004) \cite{Nanevski2004}.
Nanevski, Pfenning, and Pientka (2008) \cite{NanevskiPP2008}.
Norell (2007) \cite{Norell2007}.
Ono (1977) \cite{Ono1977}.
Pfenning and Davies (2001) \cite{PfenningD2001}.
Pientka and Abel (2015) \cite{PientkaA2015}.
Plotkin and Stirling (1986) \cite{PlotkinS1986}.
Sheard (2001) \cite{Sheard2001}.
Simpson (1994) \cite{Simpson1994}.
Stump (2016) \cite{Stump2016}.
Turner (2004) \cite{Turner2004}.
Wadler (2015) \cite{Wadler2015}.
Wickline, Lee, and Pfenning (1998) \cite{WicklineLP1998}.
Wijesekera (1990) \cite{Wijesekera1990}.


\bibliographystyle{entcs}
\bibliography{imla2017}

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

