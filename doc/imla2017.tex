%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass{entcs}

\usepackage{entcsmacro}
\usepackage{amsmath}

\usepackage[final,
            tracking=true,
            kerning=true,
            spacing=true]{microtype}
\microtypecontext{spacing=nonfrench}
\SetTracking{encoding={*},
             shape=sc}{10}
\hyphenpenalty=9999
\emergencystretch=10pt

\usepackage{epigraph}


\newcommand{\ssZ}{\textsf{\small{2}}}
\newcommand{\ssm}{\textsf{\small{m}}}
\newcommand{\ssmv}{\textsf{\small{mv}}}
\newcommand{\ssv}{\textsf{\small{v}}}
\newcommand{\ssnf}{\textsf{\small{nf}}}
\newcommand{\ssne}{\textsf{\small{ne}}}
\newcommand{\ssr}{\textsf{\small{r}}}
\newcommand{\sss}{\textsf{\small{s}}}
\newcommand{\sse}{\textsf{\small{e}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%% Syntax

% Types
\newcommand{\T}{\mathcal{T}}
% \ast
\newcommand{\R}{\mathrel{\Rightarrow}}
\newcommand{\sq}{\mathop{\Box}}

% Contexts
\newcommand{\C}{\mathcal{C}}
\newcommand{\CZ}{\mathcal{C}^{\ssZ}}
\renewcommand{\O}{\varnothing}

% Variables
% \ni
\newcommand{\zero}{\operatorname{\textsf{zero}}}
\newcommand{\suc}{\operatorname{\textsf{suc}}}

% Syntactic entailment
\renewcommand{\e}{\mathrel{\vdash}}
\newcommand{\mvar}{\operatorname{^{\ssmv}}}
\newcommand{\var}{\operatorname{^{\ssv}}}
\newcommand{\lam}{\operatorname{\lambda}}
\newcommand{\app}{\mathbin{\cdot}}
\newcommand{\quo}[1]{\mathopen{\ulcorner}{#1}\mathclose{\urcorner}}
\newcommand{\unquo}[2]{\mathopen{\llcorner}{#1}\mathclose{\lrcorner}{#2}}
\newcommand{\mvO}{\operatorname{^{\ssmv\mkern-1mu}\textsf{0}}}
\newcommand{\mvI}{\operatorname{^{\ssmv\mkern-1mu}\textsf{1}}}
\newcommand{\mvZ}{\operatorname{^{\ssmv\mkern-1mu}\textsf{2}}}
\newcommand{\vO}{\operatorname{^{\ssv\mkern-1mu}\textsf{0}}}
\newcommand{\vI}{\operatorname{^{\ssv\mkern-1mu}\textsf{1}}}
\newcommand{\vZ}{\operatorname{^{\ssv\mkern-1mu}\textsf{2}}}

% Normal and neutral forms
\newcommand{\enf}{\mathrel{\vdash_{\mkern-1mu\ssnf}}}
\newcommand{\ene}{\mathrel{\vdash_{\mkern-1mu\rlap{$\ssne$}\hphantom{\ssnf}}}}
\renewcommand{\ne}{\operatorname{\textsf{ne}}}
\newcommand{\embnf}{\operatorname{\textsf{emb}_{\ssnf}}}
\newcommand{\embne}{\operatorname{\textsf{emb}_{\ssne}}}

% Convertibility
\newcommand{\conv}{\mathrel{\sim}}
\newcommand{\bconv}{\mathrel{\sim_{\beta}}}
\newcommand{\bhconv}{\mathrel{\sim_{\beta\eta}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%% Renaming

% Order-preserving embeddings
\renewcommand{\geq}{\mathrel{\supseteq}}
\newcommand{\geqZ}{\mathrel{\supseteq^{\ssZ}}}
\newcommand{\doner}{\operatorname{\textsf{done}_{\ssr}}}
\newcommand{\wkr}{\operatorname{\textsf{wk}_{\ssr}}}
\newcommand{\liftr}{\operatorname{\textsf{lift}_{\ssr}}}

\newcommand{\mwkrZ}{\operatorname{^{\ssm\mkern-1mu}\textsf{wk}_{\ssr}^{\ssZ}}}
\newcommand{\wkrZ}{\operatorname{\textsf{wk}_{\ssr}^{\ssZ}}}
\newcommand{\infr}{\operatorname{\textsf{inf}_{\ssr}}}
\newcommand{\idr}{\operatorname{\textsf{id}_{\ssr}}}
\newcommand{\idrZ}{\operatorname{\textsf{id}_{\ssr}^{\ssZ}}}
\newcommand{\Or}{\mathbin{\circ_{\mkern-1mu\ssr}}}
\newcommand{\lookupr}{\operatorname{\textsf{lookup}_{\ssr}}}
\newcommand{\mlookuprZ}{\operatorname{^{\ssm\mkern-1mu}\textsf{lookup}_{\ssr}^{\ssZ}}}
\newcommand{\lookuprZ}{\operatorname{\textsf{lookup}_{\ssr}^{\ssZ}}}

% Renaming
\newcommand{\mren}{\operatorname{^{\ssm\mkern-1mu}\textsf{ren}}}
\newcommand{\ren}{\operatorname{\textsf{ren}}}
\newcommand{\renZ}{\operatorname{\textsf{ren}^{\ssZ}}}
\newcommand{\mrennf}{\operatorname{^{\ssm\mkern-1mu}\textsf{ren}_{\ssnf}}}
\newcommand{\mrenne}{\operatorname{^{\ssm\mkern-1mu}\textsf{ren}_{\ssne}}}
\newcommand{\rennf}{\operatorname{\textsf{ren}_{\ssnf}}}
\newcommand{\renne}{\operatorname{\textsf{ren}_{\ssne}}}
\newcommand{\rennfZ}{\operatorname{\textsf{ren}_{\ssnf}^{\ssZ}}}
\newcommand{\renneZ}{\operatorname{\textsf{ren}_{\ssne}^{\ssZ}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%% Substitution






\newcommand{\es}{\mathrel{\vdash\star}}
\newcommand{\ee}{\mathrel{\Vdash}}
\newcommand{\ees}{\mathrel{\Vdash\star}}
\newcommand{\eee}{\mathrel{\Vvdash}}
\newcommand{\ef}{\mathrel{\vDash}}

\renewcommand{\r}{\mathrel{\rightarrow}}


\newcommand{\eval}{\operatorname{\textsf{eval}}}
\newcommand{\code}{\operatorname{\textsf{code}}}
\newcommand{\N}{\mathbb{N}}


\newcommand{\Agda}{\textsc{Agda}}
\newcommand{\lambdabox}{\lambda^{\mkern-1mu\sq\mkern-3mu}}
\newcommand{\Fomega}{\textbf{F}_{\omega}}
\renewcommand{\L}{\textbf{L}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\def\lastname{Bak}

\begin{document}

\begin{frontmatter}


\title{Introspective Kripke models and\\normalisation by evaluation for the $\lambdabox$-calculus}

\author{Mi{\"e}tek Bak\thanksref{email}}

\address{Least Fixed Ltd, Cambridge, UK}

\thanks[email]{\href{mailto:mietek@bak.io}{\textnormal{\texttt{mietek@bak.io}}}}


\begin{abstract}
  We consider the Pfenning-Davies system of natural deduction: the $\lambdabox$-calculus, an extension of the simply typed $\lambda$-calculus with an intensional quotation modality, which corresponds to the necessity fragment of the modal logic S4.  We present a class of introspective Kripke models, and prove that the syntax of the $\lambdabox$-calculus is sound and complete with respect to these models.  All proofs are fully formalised in \Agda, a dependently typed total functional programming language, and have been constructed interactively, in dialogue with the machine.  The composition of the soundness and completeness proofs is a program that performs normalisation by evaluation for the $\lambdabox$-calculus.
\end{abstract}

\begin{keyword}
  constructive logic, completeness, Curry-Howard correspondence, intensionality, intuitionistic logic, Kripke semantics, modal logic S4, normalisation by evaluation, quotation, typed $\lambda$-calculus
\end{keyword}

\end{frontmatter}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introduction}
XXX

\subsection*{Related work}
XXX


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Syntax}
XXX


\begin{definition}
  Types.
  
$\T$ $\ast$ $\R$ $\sq$
\end{definition}


\begin{definition}
  Contexts.
  
$\C$ $\CZ$ $\O$
\end{definition}


\begin{definition}
  Variables.
  
$\ni$ $\zero$ $\suc$
\end{definition}


\begin{definition}
  Syntactic entailment.
  
$\e$ $\mvar$ $\var$ $\lam$ $\quo{-}$ $\unquo{-}{-}$ $\mvO$ $\mvI$ $\mvZ$ $\vO$ $\vI$ $\vZ$
\end{definition}


\begin{definition}
  Normal and neutral forms.
  
$\enf$ $\ene$ $\ne$ $\embnf$ $\embne$
\end{definition}


\begin{definition}
  Convertibility.
  
$\sim$
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection*{Renaming}
XXX


\begin{definition}
  Order-preserving embeddings.
  
$\geq$ $\geqZ$ $\doner$ $\wkr$ $\liftr$
\end{definition}


$\mwkrZ$ $\wkrZ$ $\infr$ $\idr$ $\idrZ$ $\Or$ $\lookupr$ $\mlookuprZ$ $\lookuprZ$


\begin{lemma}[Renaming]

\end{lemma}
$\mren$ $\ren$ $\renZ$ $\mrennf$ $\mrenne$ $\rennf$ $\renne$ $\rennfZ$ $\renneZ$
\begin{proof}
  XXX
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection*{Substitution}
XXX


\begin{definition}
  Simultaneous substitutions.
  
XXX
\end{definition}


\begin{lemma}[Substitution]

XXX
\end{lemma}
\begin{proof}
  XXX
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Semantics}
XXX


\begin{definition}
  Introspective Kripke models.
  
XXX
\end{definition}


\begin{definition}
  Values.
  
XXX
\end{definition}


\begin{definition}
  Environments.

XXX
\end{definition}


\begin{definition}
  Semantic entailment.

XXX
\end{definition}


\begin{lemma}[Accessibility]

XXX
\end{lemma}
\begin{proof}
  XXX
\end{proof}


\begin{theorem}[Soundness]
  
XXX
\end{theorem}
\begin{proof}
  XXX
\end{proof}


\begin{definition}
  Canonical model.
  
XXX
\end{definition}


\begin{lemma}[Canonical soundness]
  XXX
\end{lemma}
\begin{proof}
  XXX
\end{proof}


\begin{lemma}[Canonical completeness]
  XXX
\end{lemma}
\begin{proof}
  XXX
\end{proof}


\begin{theorem}[Completeness]
  
XXX
\end{theorem}
\begin{proof}
  XXX
\end{proof}


\begin{corollary}[Normalisation]
  
XXX
\end{corollary}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Conclusion}

We presented a class of introspective Kripke models, and gave a fully formalised proof of soundness and completeness of the syntax of the $\lambdabox$-calculus with respect to these models.

The author believes that this work contains the first published \emph{constructive} proof of completeness for the modal logic S4.  The proofs given by Ono \cite{Ono77}, Bo\v{z}i\'{c} and Do\v{s}en \cite{BozicD84}, Fischer Servi \cite{FischerServi84}, Ewald \cite{Ewald86}, Plotkin and Stirling \cite{PlotkinS86}, Wijesekera \cite{Wijesekera90}, Simpson \cite{Simpson94}, and Alechina \emph{et al.} \cite{AlechinaMPR01} are proceed by contradiction.

Additionally, the author believes that the normalisation by evaluation program presented in this work is the first published \emph{direct} proof of weak normalisation for the $\lambdabox$-calculus.  A proof of strong normalisation for contextual modal type theory (CMTT), which can be viewed as an extension of the $\lambdabox$-calculus, has been given by Nanevski, Pfenning, and Pientka \cite{NanevskiPP08}.

\pagebreak


\subsection*{On self-interpretation}

Self-interpretation for a total functional programming language has been almost universally considered impossible, until Brown's and Palsberg's \cite{BrownP16} demonstration of a self-interpreter for System $\Fomega$.  Bauer \cite{Bauer16} gives a precise definition of a Brown-Palsberg self-interpreter, which we adopt here.

Following Bauer, we write $\mathfrak{g}(M)$ for the G\"{o}del code of a term $M$, which is a suitable encoding of $M$ by a natural number, and $\underline{n}$ for the numeral that represents a natural number $n$.

\begin{definition}
  A \emph{Brown-Palsberg self-interpreter} is an evaluation function, $\textsf{t} : \O \e \sq A \R A$, such that $\textsf{t} \quo{M} \bconv M$ for all $M : \O \e A$.  A quotation operator is \emph{normal} when $\quo{M}$ is $\beta$-normal for all $M : \O \e A$, and \emph{acceptable} when there is a G\"{o}del-coding function, $\textsf{g} : \O \e \sq A \R \underline{\N}$, such that $\textsf{g} \quo{M} = \underline{\mathfrak{g}(M)}$ for all $M : \O \e A$.
\end{definition}

\begin{theorem}
  The $\lambdabox$-calculus has a Brown-Palsberg self-interpreter.
\end{theorem}
\begin{proof}
  Define $\textsf{t} = \lam (\unquo{\vO}{\mvO})$.
\end{proof}

It is clear that the $\lambdabox$-calculus has a normal quotation operator.  However




\subsection*{Acknowledgements}

The author is deeply grateful to Andreas Abel, Guillaume Allais, Ahmad Salim Al-Sibahi, Roy Dyckhoff, Michael Gabbay, Paolo G. Giarrusso, Tom Jack, Roman Kireev, Jerzy Marcinkowski, Darryl McAdams, Conor McBride, Dominic Orchard, Maciej Pir\'{o}g, Ida Szubert, Tarmo Uustalu, Andrea Vezzosi, and Tomasz Wierzbicki, for many fruitful discussions over the years.

Furthermore, the author thanks Sergei Art\"emov, Andrej Bauer, Jacques Carette, Danko Ili\'{c}, Alex Kavvos, and the anonymous reviewers, for comments that helped improve this work.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bibliographystyle{entcs}
\bibliography{imla2017}

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% Some say that in \textsc{Lisp}, code is data.  Instead, we say that code may be $\quot$ed to become data, and data may be $\eval$uated to become code.
