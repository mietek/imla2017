%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass{entcs}
\usepackage{entcsmacro}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}

\usepackage[activate={true,nocompatibility},
            final,
            tracking=true,
            kerning=true,
            spacing=true,
            factor=1100,
            stretch=10,
            shrink=10]{microtype}
\microtypecontext{spacing=nonfrench}
\SetTracking{encoding={*},
             shape=sc}{10}
\emergencystretch=10pt

\usepackage{prftree}
\prfinterspace=1.5em
% \prflinepadbefore=1pt
% \prflinepadafter=3pt

\usepackage{environ}
\NewEnviron{proofalign*}{%
  \setlength{\abovedisplayskip}{0pt}%
  \setlength{\belowdisplayskip}{0pt}%
  \setlength{\abovedisplayshortskip}{0pt}%
  \setlength{\belowdisplayshortskip}{0pt}%
  \begin{proof}%
    \vspace{-\baselineskip}%
    \begin{align*}%
      \BODY%
    \end{align*}%
    \vspace{-2.75\baselineskip}\[\]%
  \end{proof}}
\NewEnviron{proofalignat*}[1]{%
  \setlength{\abovedisplayskip}{0pt}%
  \setlength{\belowdisplayskip}{0pt}%
  \setlength{\abovedisplayshortskip}{0pt}%
  \setlength{\belowdisplayshortskip}{0pt}%
  \begin{proof}%
    \vspace{-\baselineskip}%
    \begin{alignat*}{#1}%
      \BODY%
    \end{alignat*}%
    \vspace{-2.75\baselineskip}\[\]%
  \end{proof}}

% NOTE: Used to get "de Bruijn" to sort under "B"
\newcommand{\noopsort}[2]{#2}

\usepackage{float}
\restylefloat{figure}
\usepackage[font=small,
            labelfont=bf,
            labelsep=period,
            figurename=Figure]{caption}

\numberwithin{equation}{thm}

\usepackage{lipsum}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\lambdabox}{\lambda^{\mkern-1mu\sq\mkern-2mu}}

\newcommand{\preop}[1]{\mathord{#1}-}
\newcommand{\postop}[1]{-\mathord{#1}}
\newcommand{\binop}[1]{-\mathord{#1}-}

\newcommand{\tsf}[1]{\textsf{\upshape{#1}}}
\newcommand{\stsf}[1]{\smash{\tsf{\small{#1}}}}

\newcommand{\Set}{\tsf{Set}}
\renewcommand{\:}{\mathrel{:}}
\newcommand{\widecolon}{\mathrel{\rlap{$\mkern4.5mu:$}\hphantom{=}}}
\renewcommand{\r}{\mathrel{\rightarrow}}

\newcommand{\tyrule}[1]{\prftree[l]{${#1} \:\,$}}
\newcommand{\padtyrule}[1]{\prftree[l]{${#1} \widecolon\,$}}
\newcommand{\eqrule}[1]{\prftree[l]{${#1} =$}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Prelude


\newcommand{\id}{\operatorname{\tsf{id}}}
\newcommand{\comp}{\mathrel{\circ}}

\newcommand{\projI}{\operatorname{\tsf{proj}_{\stsf{1}}}}
\newcommand{\projZ}{\operatorname{\tsf{proj}_{\stsf{2}}}}
\newcommand{\comma}{\mathbin{,}}

\let\oldforall\forall
\renewcommand{\forall}{\oldforall\,}

\let\oldexists\exists
\renewcommand{\exists}{\oldexists\,}

\newcommand{\0}{\varnothing}

\newcommand{\zero}{\operatorname{\tsf{zero}}}
\newcommand{\suc}{\operatorname{\tsf{suc}}}


\newcommand{\List}{\operatorname{\tsf{List}}}
\newcommand{\All}{\operatorname{\tsf{All}}}

\renewcommand{\geq}{\mathrel{\supseteq}}

\newcommand{\done}{\operatorname{\tsf{done}}}
\newcommand{\wk}{\operatorname{\tsf{wk}}}
\newcommand{\lift}{\operatorname{\tsf{lift}}}

\newcommand{\infr}{\operatorname{\tsf{inf}_{\stsf{r}}}}
\newcommand{\idr}{\operatorname{\tsf{id}_{\stsf{r}}}}
\newcommand{\compr}{\mathrel{\circ_{\mkern-1mu\stsf{r}}}}

\newcommand{\lookupr}{\operatorname{\tsf{lookup}_{\stsf{r}}}}

\newcommand{\ListZ}{\operatorname{\tsf{List}^{\stsf{2}}}}

\newcommand{\geqZ}{\mathrel{\supseteq^{\stsf{2}}}}

\newcommand{\mwkZ}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{wk}^{\stsf{2}}}}
\newcommand{\wkZ}{\operatorname{\tsf{wk}^{\stsf{2}}}}

\newcommand{\ideZ}{\operatorname{\tsf{id}_{\stsf{r}}^{\stsf{2}}}}
\newcommand{\compeZ}{\mathrel{\circ_{\mkern-1mu\stsf{r}}^{\stsf{2}}}}

\newcommand{\mlookuprZ}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{lookup}_{\stsf{r}}^{\stsf{2}}}}
\newcommand{\lookuprZ}{\operatorname{\tsf{lookup}_{\stsf{r}}^{\stsf{r}}}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Syntax

\newcommand{\Tp}{\operatorname{\tsf{Tp}}}

% \newcommand{\tvar}{\operatorname{^{\stsf{tv}\mkern-4mu}}}
% \newcommand{\R}{\Rightarrow}
\newcommand{\base}{\flat}
\newcommand{\imp}{\mathbin{\supset}}
\renewcommand{\and}{\mathbin{\wedge}}
\newcommand{\sq}{\Box}

\newcommand{\Cx}{\tsf{Cx}}

\newcommand{\D}{\mathcal{D}}
\newcommand{\E}{\mathcal{E}}

\renewcommand{\e}{\mathrel{\vdash}}

\newcommand{\mvar}{\operatorname{^{\stsf{mv}\mkern-2mu}}}
\newcommand{\var}{\operatorname{^{\stsf{v}\mkern-2mu}}}
\newcommand{\lam}{\operatorname{\lambda}}
\newcommand{\app}{\mathbin{\$}}
\newcommand{\quo}[1]{\mathopen{\ulcorner}{#1}\mathclose{\urcorner}}
\newcommand{\unq}[1]{\mathopen{\llcorner}{#1}\mathclose{\lrcorner}\,}

\newcommand{\enm}{\mathrel{\vdash_{\mkern-2mu\stsf{nm}}}}
\newcommand{\ent}{\mathrel{\vdash_{\mkern-2mu\stsf{nt}}}}

\newcommand{\nt}{\operatorname{^{\stsf{nt}\mkern-1mu}}}

\newcommand{\embnm}{\operatorname{\tsf{emb}_{\stsf{nm}}}}
\newcommand{\embnt}{\operatorname{\tsf{emb}_{\stsf{nt}}}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Renaming


\newcommand{\mren}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{ren}}}
\newcommand{\ren}{\operatorname{\tsf{ren}}}

\newcommand{\mrennm}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{ren}_{\stsf{nm}}}}
\newcommand{\mrennt}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{ren}_{\stsf{nt}}}}
\newcommand{\rennm}{\operatorname{\tsf{ren}_{\stsf{nm}}}}
\newcommand{\rennt}{\operatorname{\tsf{ren}_{\stsf{nt}}}}

\newcommand{\rennmZ}{\operatorname{\tsf{ren}_{\stsf{nm}}^{\stsf{2}}}}
\newcommand{\renntZ}{\operatorname{\tsf{ren}_{\stsf{nt}}^{\stsf{2}}}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Substitution


\newcommand{\es}{\mathrel{\vdash_{\mkern-2mu\star\mkern-2mu}}}

\newcommand{\mrens}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{ren}_{\star\mkern-2mu}}}
\newcommand{\rens}{\operatorname{\tsf{ren}_{\star\mkern-2mu}}}

\newcommand{\mwks}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{wk}_{\stsf{s}}}}
\newcommand{\wks}{\operatorname{\tsf{wk}_{\stsf{s}}}}
\newcommand{\mlifts}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{lift}_{\stsf{s}}}}
\newcommand{\lifts}{\operatorname{\tsf{lift}_{\stsf{s}}}}

\newcommand{\mids}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{id}_{\stsf{s}}}}
\newcommand{\ids}{\operatorname{\tsf{id}_{\stsf{s}}}}

\newcommand{\lookups}{\operatorname{\tsf{lookup}_{\stsf{s}}}}
\newcommand{\msub}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{sub}}}
\newcommand{\sub}{\operatorname{\tsf{sub}}}



%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Semantics


\newcommand{\K}{\mathfrak{K}}
\newcommand{\M}{\mathfrak{M}}
\newcommand{\Mover}{\M\,|\,}
\newcommand{\W}{\mathcal{W}}
\newcommand{\V}{\operatorname{\mathcal{V}}}
\newcommand{\ida}{\operatorname{\tsf{id}_{\stsf{a}}}}
\newcommand{\compa}{\mathrel{\circ_{\stsf{a}}}}
\newcommand{\relv}{\operatorname{\tsf{rel}_{\stsf{v}}}}
\newcommand{\peek}[1]{\mathopen{\lfloor}{#1}\mathclose{\rfloor}}
\newcommand{\peeka}[1]{\mathopen{\lfloor}{#1}\mathclose{\rfloor_{\mkern-2mu\stsf{a}}}}

\newcommand{\mpeek}[1]{\mathopen{^{\stsf{m}\mkern-3mu}\lfloor}{#1}\mathclose{\rfloor}}
\newcommand{\mpeeka}[1]{\mathopen{^{\stsf{m}\mkern-3mu}\lfloor}{#1}\mathclose{\rfloor_{\mkern-2mu\stsf{a}}}}

\newcommand{\ee}{\mathrel{\Vdash}}
\newcommand{\eek}{\mathrel{\Vdash_{\stsf{k}}}}
\newcommand{\eej}{\mathrel{\Vdash_{\stsf{j}}}}
\newcommand{\eejk}{\mathrel{\Vdash_{\stsf{jk}}}}
\newcommand{\syn}{\operatorname{\tsf{syn}}}
\newcommand{\sem}{\operatorname{\tsf{sem}}}

\newcommand{\ees}{\mathrel{\Vdash_{\mkern-2mu\star\mkern-2mu}}}
\newcommand{\eeks}{\mathrel{\Vdash_{\stsf{k}\star\mkern-2mu}}}
\newcommand{\eejs}{\mathrel{\Vdash_{\stsf{j}\star\mkern-2mu}}}
\newcommand{\eejks}{\mathrel{\Vdash_{\stsf{jk}\star\mkern-2mu}}}
\newcommand{\syns}{\operatorname{\tsf{syn}_{\star}}}
\newcommand{\sems}{\operatorname{\tsf{sem}_{\star}}}

\newcommand{\eeq}{\mathrel{\vDash}}

\newcommand{\rel}{\operatorname{\tsf{rel}}}
\newcommand{\relk}{\operatorname{\tsf{rel}_{\stsf{k}}}}
\newcommand{\reljk}{\operatorname{\tsf{rel}_{\stsf{jk}}}}
\newcommand{\relks}{\operatorname{\tsf{rel}_{\stsf{k}\star}}}
\newcommand{\reljks}{\operatorname{\tsf{rel}_{\stsf{jk}\star}}}

\newcommand{\return}{\operatorname{\tsf{return}}}
\newcommand{\bind}{\operatorname{\tsf{bind}}}

\newcommand{\lookup}{\operatorname{\tsf{lookup}}}

\newcommand{\reflect}{\operatorname{\downarrow}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Completeness


\newcommand{\Mu}{\mathfrak{M}_{\stsf{u}}}
\newcommand{\Vu}{\mathcal{V}_{\stsf{u}}}

\newcommand{\reifyu}{\operatorname{\uparrow_{\stsf{u}}}}
\newcommand{\reflectu}{\operatorname{\downarrow_{\stsf{u}}}}

\newcommand{\mide}{\operatorname{^{\stsf{m}\mkern-2mu}\tsf{id}_{\stsf{e}}}}
\newcommand{\ide}{\operatorname{\tsf{id}_{\stsf{e}}}}
\newcommand{\reify}{\operatorname{\uparrow}}

\newcommand{\nm}{\operatorname{\tsf{nm}}}


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.

% Examples


\newcommand{\mvO}{\operatorname{^{\stsf{mv}\mkern-1mu}\tsf{0}}}
\newcommand{\mvI}{\operatorname{^{\stsf{mv}\mkern-1mu}\tsf{1}}}
\newcommand{\mvZ}{\operatorname{^{\stsf{mv}\mkern-1mu}\tsf{2}}}
\newcommand{\vO}{\operatorname{^{\stsf{v}\mkern-1mu}\tsf{0}}}
\newcommand{\vI}{\operatorname{^{\stsf{v}\mkern-1mu}\tsf{1}}}
\newcommand{\vZ}{\operatorname{^{\stsf{v}\mkern-1mu}\tsf{2}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\def\lastname{Bak}

\begin{document}

\begin{frontmatter}

\title{Introspective Kripke models\\and normalisation-by-evaluation\\for the $\lambdabox$-calculus}

\author{Mi\"{e}tek Bak\thanksref{email}}

\address{Least Fixed Ltd, Cambridge, UK}

\thanks[email]{\href{mailto:mietek@bak.io}{\textnormal{\texttt{mietek@bak.io}}}}


\begin{abstract}
  We consider the $\lambdabox$-calculus, an extension of the simply typed $\lambda$-calculus with a type of quoted programs that corresponds to the $\sq$ connective of the modal logic S4.
  We present a novel class of \emph{introspective} Kripke models, constructed in continuation-passing style, and prove the syntax of the $\lambdabox$-calculus sound and complete with respect to these models.
  We fully formalise the arguments in \textsc{Agda}, a dependently typed total functional programming language based on intensional type theory.
  The composition of our soundness and completeness proofs is an \textsc{Agda} program that performs normalisation-by-evaluation for the $\lambdabox$-calculus.
\end{abstract}

\begin{keyword}
  constructive logic, continuation-passing style, completeness, Curry-Howard correspondence, intensionality, intuitionistic logic, Kripke semantics, meta-programming, modal logic S4, normalisation-by-evaluation, quotation, self-interpretation, typed $\lambda$-calculus
\end{keyword}

\end{frontmatter}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introduction}


I'd like to have a total functional programming language that works like Lisp; that is, a language that allows programs to be quoted, inspected, and evaluated, in which types are propositions and programs are proofs.
Some people have been using the modal logic S4 for similar purposes.
I quickly found a reasonable $\lambda$-calculus based on S4, that is, the $\lambdabox$-calculus, and I set out to write an interpreter for it.
\begin{gather*}
  \prftree{\Delta \ni A}{\Delta; \Gamma \e A}\qquad
  \prftree{\Delta; \0 \e A}{\Delta; \Gamma \e \sq A}\qquad
  \prftree{\Delta; \Gamma \e \sq A}{\Delta, A; \Gamma \e C}{\Delta; \Gamma \e C}
\end{gather*}
It's well-known that if we prove a language sound and complete with respect to some class of models, then an interpreter falls out --- as long as the proofs are constructive.
Unfortunately, all I could find was classical proofs of completeness for S4, and so I decided to do the proofs myself.

It's also well-known how to prove STLC sound and complete with respect to intuitionistic Kripke semantics.
Since the $\lambdabox$-calculus is an extension of STLC, I thought it should be simple to extend intuitionistic Kripke semantics and obtain the desired proofs.
Famous last words!
Eventually, I realised that the interpretation of $\sq A$ should be a syntactically-justified interpretation of $A$; that is, a pair consisting of a term of $A$ and an interpretation of $A$.
\begin{alignat*}{2}
  & \Delta; \Gamma \ee \sq A \,&&=\, \forall \Delta' \geq \Delta,\,\Gamma' \geq \Gamma.\ \Delta'; \Gamma' \eej A\\[0.5\baselineskip]
  & \Delta; \Gamma \eej A    \,&&=\, \Delta; \0 \e A \times \Delta; \Gamma \ee A
\end{alignat*}
This puts the syntax in the semantics --- peeks beneath the veil sooner than expected.
We can still keep the abstraction of a Kripke semantics, as long as we can discard it when we need to.
  \[\M \,=\, \langle\,\W,\,\V,\,\binop{\ge},\,\ida,\,\binop{\compa},\,\relv,\,\peek{-},\,\peeka{-}\,\rangle\]
Now, we can try to write the interpretation of $\sq A$ using the model.
\begin{alignat*}{2}
  & \Mover w \ee \sq A \,&&=\, \forall w' \ge w.\ \Mover w' \eej A\\[0.5\baselineskip]
  & \Mover w \eej A    \,&&=\, \mpeek{w}; \0 \e A \times \Mover w \ee A
\end{alignat*}
However, adding this interpretation to intuitionistic Kripke semantics allows us to prove soundness, but not completeness.
The problem with proving completeness with respect to the modified semantics is similar to the problem with proving completeness of full STLC, with disjunction and the empty type.
Some people have already come up with a solution to that, which is a CPS transformation of the semantics.
\begin{alignat*}{2}
  & \Mover w \ee \sq A \,&&=\, \forall w' \ge w.\ \Mover w' \eejk A\\
  & \Mover w \eek A    \,&&=\, \forall C,\,w' \ge w.\ \raisebox{-8pt}{\prftree{\raisebox{8pt}{$\forall w'' \ge w'\mkern-2mu.\ $}\prftree{\Mover w'' \ee A}{\lfloor w'' \rfloor \enm C}}{\lfloor w' \rfloor \enm C}}\\[0.5\baselineskip]
  & \Mover w \eejk A \,&&=\, \mpeek{w}; \0 \e A \times \Mover w \eek A
\end{alignat*}
It turns out that CPS transforming the modified semantics allows us to prove soundness and completeness, and so, to write an interpreter for the $\lambdabox$-calculus.
  \[\Delta; \Gamma \eeq A \,=\, \forall \M,\,w.\ \raisebox{-8pt}{$\prftree{\Mover w \eejks \Delta}{\Mover w \eeks \Gamma}{\Mover w \eek A}$}\]
\begin{theorem}[Soundness]
  \[\tyrule{\reflect}{\Delta; \Gamma \e A}{\Delta; \Gamma \eeq A}\]
\end{theorem}
\begin{theorem}[Completeness]
  \[\tyrule{\reify}{\Delta; \Gamma \eeq A}{\Delta; \Gamma \enm A}\]
\end{theorem}
\begin{corollary}[Normalisation]
  Every program of the $\lambdabox$-calculus has a normal form.
  \[\tyrule{\nm}{\Delta; \Gamma \e A}{\Delta; \Gamma \enm A}\]
  \begin{proof}\normalshape % XXX
    By composition of soundness (Theorem \ref{soundness}) and completeness (Theorem \ref{completeness}).
    \[\nm \,=\, \reify \comp \reflect\]
  \end{proof}
\end{corollary}\noindent % XXX
I've done that now, and I think this interpreter can be used to decide $\beta\eta$-equivalence according to the following convertibility relation, but I haven't managed to prove this yet.

To prove completeness, we need a canonical model.
\begin{theorem}
  There exists a canonical model.
  \begin{proof}\normalshape % XXX
    \begin{gather*}
      \Mu \,=\, \langle\,\Cx,\,\Vu,\,\binop{\geqZ},\,\ideZ,\,\binop{\compeZ},\,\rennmZ,\,\id,\,\id\,\rangle\\[0.5\baselineskip]
      \Delta; \Gamma \Vu x \,=\, \Delta; \Gamma \enm \mkern-4mu \base
    \end{gather*}
  \end{proof}
\end{theorem}\noindent % XXX
We first prove soundness and completeness with respect to this canonical model, and then use that to prove completeness proper.
\begin{gather*}
  \tyrule{\reflectu}{\Delta; \Gamma \ent A}{\Mu\,|\,\Delta; \Gamma \eek A}\qquad
  \tyrule{\reifyu}{\Mu\,|\,\Delta; \Gamma \eek A}{\Delta; \Gamma \enm A}
\end{gather*}

\paragraph{Contributions}
\lipsum[1-2]



\section{Syntax}

\begin{definition}
  Syntactic entailment.
  \begin{gather*}
    \tyrule{\mvar}{\Delta \ni A}{\Delta; \Gamma \e A}\qquad
    \tyrule{\var}{\Gamma \ni A}{\Delta; \Gamma \e A}\\[0.5\baselineskip]
    \tyrule{\lam}{\Delta; \Gamma, A \e B}{\Delta; \Gamma \e A \imp B}\qquad
    \tyrule{\binop{\app}}{\Delta; \Gamma \e A \imp B}{\Delta; \Gamma \e A}{\Delta; \Gamma \e B}\\[0.5\baselineskip]
    \tyrule{\quo{-}}{\Delta; \0 \e A}{\Delta; \Gamma \e \sq A}\qquad
    \tyrule{\unq{-}}{\Delta; \Gamma \e \sq A}{\Delta, A; \Gamma \e C}{\Delta; \Gamma \e C}
  \end{gather*}
\end{definition}

\begin{example}
  Axioms of S4.
  \begin{align*}
    & \tsf{D} \widecolon \Delta; \Gamma \e \sq (A \imp B) \imp \sq A \imp \sq B\\
    & \tsf{D} = \lam\, (\lam\, (\unq{\vI}\, \quo{\mvI \app \mvO}))\\[0.5\baselineskip]
    & \tsf{T} \widecolon \Delta; \Gamma \e \sq A \imp A\\
    & \tsf{T} = \lam\, (\unq{\vO} \mvO)\\[0.5\baselineskip]
    & \tsf{4} \widecolon \Delta; \Gamma \e \sq A \imp \sq \sq A\\
    & \tsf{4} = \lam\, (\unq{\vO}\, \quo{\quo{\mvO}})
  \end{align*}
\end{example}

\begin{definition}
  Normal forms and neutral forms.
  \begin{gather*}
    \tyrule{\lam}{\Delta; \Gamma, A \enm B}{\Delta; \Gamma \enm A \imp B}\\[0.5\baselineskip]
    \tyrule{\quo{-}}{\Delta; \0 \e A}{\Delta; \Gamma \enm \sq A}\qquad
    \tyrule{\unq{-}}{\Delta; \Gamma \ent \sq A}{\Delta, A; \Gamma \enm C}{\Delta; \Gamma \enm C}\\[0.5\baselineskip]
    \tyrule{\nt}{\Delta; \Gamma \ent \base}{\Delta; \Gamma \enm \base}\\[0.5\baselineskip]
    \tyrule{\mvar}{\Delta \ni A}{\Delta; \Gamma \ent A}\qquad
    \tyrule{\var}{\Gamma \ni A}{\Delta; \Gamma \ent A}\\[0.5\baselineskip]
    \tyrule{\binop{\app}}{\Delta; \Gamma \ent A \imp B}{\Delta; \Gamma \enm A}{\Delta; \Gamma \ent B}
  \end{gather*}
\end{definition}

\lipsum[1-5]


\section{Semantics}

\begin{definition}
  \textbf{(Introspective Kripke models)\ }
  An \emph{introspective Kripke model} is a tuple that contains a \emph{set of worlds} $\W$, an unary \emph{valuation relation} on worlds $\V$, a binary \emph{accessibility relation} on worlds $\binop{\ge}$, a \emph{world introspection function} $\peek{-}$, and an \emph{accessibility introspection function} $\peeka{-}$.
  Accessibility is reflexive and transitive, as witnessed by $\ida$ and $\binop{\compa}$, and valuation is monotonic with respect to accessibility, as witnessed by $\relv$.
  World introspection maps worlds to contexts, and accessibility introspection maps elements of the accessibility relation to order-preserving embeddings on contexts.
  \begin{gather*}
    \M \,=\, \langle\, \W,\, \V,\, \binop{\ge},\, \ida,\, \binop{\compa},\, \relv,\, \peek{-},\, \peeka{-}\, \rangle
  \end{gather*}
\end{definition}

\noindent
We read $\V w$ as the valuation at world $w$.
We write $w' \ge w$ to say that the world $w'$ is accessible from $w$.
We refer to an application of monotonicity as a \emph{relocation}.
As shorthand, we use \emph{modal world introspection} $\mpeek{-}$ to map a world directly to the modal projection of a context, and \emph{modal accessibility introspection} $\mpeeka{-}$ to map an element of the accessibility relation directly to the modal projection of an order-preserving embedding on contexts.

\begin{definition}
  \textbf{(Values)\ }
  \label{ee/eek/eejk}
  A \emph{value} of type $A$ at world $w$ of introspective Kripke model $\M$, written $\Mover w \ee A$, is defined by mutual induction on the type, together with value continuations and justified value continuations.
  
  For the base type $\flat$ \eqref{ee.tvar}, the value at $w$ is given by the valuation at $w$.
  For function types $A \imp B$ \eqref{ee.imp}, the value at $w$ is a function that, for every $w'$ accessible from $w$, takes a value continuation of type $A$ at $w'$ and returns a value continuation of type $B$ at $w'$.
  For quotation types $\sq A$ \eqref{ee.sq}, the value at $w$ is a justified value continuation of type $A$ at $w$.
  
  A \emph{value continuation} of type $A$ at $w$ of $\M$, written $\Mover w \eek A$ \eqref{eek}, is a function that, for every type $C$ and $w'$ accessible from $w$, takes a continuation that, for every $w''$ accessible from $w'$, consumes a value of type $A$ at $w''$ and produces a normal term of type $C$ in context $\peek{w''}$.
  The result is a normal term of type $C$ in context $\peek{w'}$.
  
   A \emph{justified value continuation} of type $A$ at $w$ of $\M$, written $\Mover w \eejk A$ \eqref{eejk}, is a product of a term of type $A$ in context $\mpeek{w}; \0$ and a value continuation of type $A$ at $w$.
  \begin{alignat}{3}
    \label{ee.tvar} & \rlap{$\Mover w \ee \base$}    &&\,&&=\, \V w\\
    \label{ee.imp}  & \rlap{$\Mover w \ee A \imp B$} &&\,&&=\, \forall w' \ge w.\ \raisebox{-8pt}{\prftree{\Mover w' \eek A} {\Mover w' \eek B}}\\
    \label{ee.sq}   & \rlap{$\Mover w \ee \sq A$}    &&\,&&=\, \Mover w \eejk A\\[0.5\baselineskip]
    \label{eek}     && \ \quad \Mover w \eek A        &\,&&=\, \forall C,\,w' \ge w.\ \raisebox{-8pt}{\prftree{\raisebox{8pt}{$\forall w'' \ge w'\mkern-4mu.\ $} \prftree{\Mover w'' \ee A}{\lfloor w'' \rfloor \enm C}}{\lfloor w' \rfloor \enm C}}\\[\baselineskip]
    \label{eejk}    && \ \quad \Mover w \eejk A       &\,&&=\, \mpeek{w}; \0 \e A \times \Mover w \eek A
  \end{alignat}
\end{definition}

\begin{lemma}
  \normalshape
  \label{syn/sem}
  Given a justified value continuation $p$ of type $A$ at $w$ of $\M$, there is a term of type $A$ in context $\mpeek{w}; \0$, referred to as the \emph{syntactic projection} of $p$, and a value continuation of type $A$ at $w$, referred to as the \emph{semantic projection} of $p$.
  \begin{gather*}
    \tyrule{\syn}{\Mover w \eejk A}{\mpeek{w}; \0 \e A}\qquad
    \tyrule{\sem}{\Mover w \eejk A}{\Mover w \eek A}
  \end{gather*}
  Proved by product elimination.
\end{lemma}

\begin{lemma}
  \normalshape
  \label{rel/relk/reljk}
  For every world $w'$ accessible from $w$ of $\M$, given a value (value continuation; justified value continuation) of type $A$ at $w$, there is a value (value continuation; justified value continuation) of type $A$ at $w'$.
  \begin{gather*}
    \tyrule{\rel}{w' \ge w}{\Mover w \ee A}{\Mover w' \ee A}\\[0.5\baselineskip]
    \tyrule{\relk}{w' \ge w}{\Mover w \eek A}{\Mover w' \eek A}\qquad
    \tyrule{\reljk}{w' \ge w}{\Mover w \eejk A}{\Mover w' \eejk A}
  \end{gather*}
  \itshape
  \begin{proof}
    \normalshape
    By mutual induction on the type, and lemmas \ref{mren} and \ref{syn/sem}.
    \begin{alignat*}{3}
      & \rlap{$\rel\, \{\base\}$}     &\,\xi\, &\,v \,&&=\, \relv \xi\, v\\
      & \rlap{$\rel\, \{A \imp B\}$}  &\,\xi\, &\,f \,&&=\, \xi'\, k \mapsto f\, (\xi \compa \xi')\, k\\
      & \rlap{$\rel\, \{\sq A\}$}     &\,\xi\, &\,p \,&&=\, \reljk \xi\, p\\[0.5\baselineskip]
      && \qquad\quad \relk             \,\xi\, &\,k \,&&=\, \xi'\, f \mapsto k\, (\xi \compa \xi')\, f\\[0.5\baselineskip]
      && \qquad\quad \reljk            \,\xi\, &\,p \,&&=\, \mren\, \mpeeka{\xi}\, (\syn p),\, \relk \xi\, (\sem p)
    \end{alignat*}
  \end{proof}
\end{lemma}

\begin{lemma}
  \normalshape
  \label{return/bind}
  Value continuations form a monad.
  \begin{gather*}
    \tyrule{\return}{\Mover w \ee A}{\Mover w \eek A}\qquad
    \tyrule{\bind}{\Mover w \eek A}{\raisebox{8pt}{$\forall w' \ge w.\ $} \prftree{\Mover w' \ee A}{\Mover w' \eek C}}{\Mover w \eek C}
  \end{gather*}
  \itshape
  \begin{proof}
    \normalshape
    By lemma \ref{rel/relk/reljk}.
    \begin{alignat*}{3}
      & \return\,a    \,&&=\, &&\,\xi\, f \mapsto f \ida\, (\rel \xi\, a)\\[0.5\baselineskip]
      & \bind\, k\, f \,&&=\, &&\,\xi\, f' \mapsto k\, \xi\, (\xi'\, a \mapsto\\
      &                 &&    &&\quad f\, (\xi \compa \xi')\, a \ida\, (\xi''\, b \mapsto\\
      &                 &&    &&\quad\quad f'\, (\xi' \compa \xi'')\, b))
    \end{alignat*}
  \end{proof}
\end{lemma}

\begin{definition}
  \textbf{(Environments)\ }
  \label{eeks/eejks}
  An \emph{environment} of types $\Gamma$ at $w$ of $\M$, written $\Mover w \eeks \Gamma$, is a mapping that assigns to every type $A$ in $\Gamma$ a value continuation of $A$ at $w$.
  
  A \emph{justified environment} of types $\Delta$ at $w$ of $\M$, written $\Mover w \eejks \Delta$, is a mapping that assigns to every type $A$ in $\Delta$ a justified value continuation of $A$ at $w$.
\end{definition}

\begin{lemma}
  \normalshape
  \label{syns/sems}
  Given a justified environment $\delta$ of types $\Delta$ at $w$ of $\M$, there is a simultaneous substitution of types $\Delta$ in context $\mpeek{w}; \0$, referred to as the \emph{syntactic projection} of $\delta$, and an environment of types $\Delta$ at $w$ of $\M$, referred to as the \emph{semantic projection} of $\delta$.
  \begin{gather*}
    \tyrule{\syns}{\Mover w \eejks \Delta}{\mpeek{w}; \0 \es \Delta}\qquad
    \tyrule{\sems}{\Mover w \eejks \Delta}{\Mover w \eeks \Delta}
  \end{gather*}
  Proved by induction on the justified environment and lemma \ref{syn/sem}.
\end{lemma}

\begin{lemma}
  \normalshape
  \label{relks/reljks}
  For every world $w'$ accessible from $w$ of $\M$, given an environment of types $\Gamma$ at $w$, there is an environment of types $\Gamma$ at $w'$.
  
  For every world $w'$ accessible from $w$ of $\M$, given a justified environment of types $\Delta$ at $w$, there is a justified environment of types $\Delta$ at $w'$.
  \begin{gather*}
    \tyrule{\relks}{w' \ge w}{\Mover w \eeks \Gamma}{\Mover w' \eeks \Gamma}\qquad
    \tyrule{\reljks}{w' \ge w}{\Mover w \eejks \Delta}{\Mover w' \eejks \Delta}
  \end{gather*}
  Proved by induction on the environment (justified environment) and lemma \ref{rel/relk/reljk}.
\end{lemma}

\begin{lemma}
  \normalshape
  \label{lookup}
  Given an environment of types $\Gamma$ at $w$ of $\M$, for every type $A$ in $\Gamma$, there is a value continuation of type $A$ at $w$.
  \begin{gather*}
    \tyrule{\lookup}{\Mover w \eeks \Gamma}{\Gamma \ni A}{\Mover w \eek A}
  \end{gather*}
  Proved by induction on the environment.
\end{lemma}

\begin{definition}
  \textbf{(Semantic entailment)\ }
  \label{eeq}
  We say that the context $\Delta; \Gamma$ \emph{semantically entails} the type $A$ when, for every world $w$ of every model $\M$, given a justified environment of types $\Delta$ at $w$ and an environment of types $\Gamma$ at $w$, there is a value continuation of type $A$ at $w$.
  \begin{gather*}
    \Delta; \Gamma \eeq A \,=\, \forall \M,\,w.\ \raisebox{-8pt}{$\prftree{\Mover w \eejks \Delta}{\Mover w \eeks \Gamma}{\Mover w \eek A}$}
  \end{gather*}
\end{definition}

\begin{theorem}
  \normalshape
  \textbf{(Soundness)\ }
  \label{reflect}
  If the context $\Delta; \Gamma$ syntactically entails the type $A$, then the context $\Delta; \Gamma$ semantically entails the type $A$.
  \begin{gather*}
    \tyrule{\reflect}{\Delta; \Gamma \e A}{\Delta; \Gamma \eeq A}
  \end{gather*}
  \itshape
  \pagebreak %% XXX 
  \begin{proof}
    \normalshape
    By induction on the term, and lemmas \ref{return/bind}, \ref{syns/sems}, \ref{relks/reljks}, and \ref{lookup}.
    \begin{alignat}{3}
      \label{reflect.mvar} & \reflect\, (\mvar i)    \,&&=\, &&\,\delta\, \gamma \mapsto \lookup\, (\sems \delta)\, i\\
      \label{reflect.var}  & \reflect\, (\var i)     \,&&=\, &&\,\delta\, \gamma \mapsto \lookup \gamma\, i\\
      \label{reflect.lam}  & \reflect\, (\lam M)     \,&&=\, &&\,\delta\, \gamma \mapsto \return\, (\xi\,k \mapsto\\
      \nonumber            & && && \quad \reflect M\, (\reljks \xi\, \delta)\, (\relks \xi\, \gamma,\, k))\\
      \label{reflect.app}  & \reflect\, (M \app N) \,&&=\, &&\,\delta\, \gamma \mapsto \bind\, (\reflect M\, \delta\, \gamma)\, (\xi\,f \mapsto\\
      \nonumber            & && && \quad f \ida\, (\reflect N\, (\reljks \xi\, \delta)\, (\relks \xi\, \gamma)))\\
      \label{reflect.quo}  & \reflect\, (\quo{M})   \,&&=\, &&\,\delta\, \gamma \mapsto \return\, (\msub\, (\syns \delta)\, M,\, \reflect M\, \delta\, \0)\\
      \label{reflect.unq}  & \reflect\, (\unq{M} N) \,&&=\, &&\,\delta\, \gamma \mapsto \bind\, (\reflect M\, \delta\, \gamma)\, (\xi\,p \mapsto\\
      \nonumber            & && && \quad \reflect N\, (\reljks \xi\, \delta,\, p)\, (\relks \xi\, \gamma))
    \end{alignat}
  \end{proof}
\end{theorem}
\noindent
The proof of soundness $\reflect$ is an \emph{evaluation function} for $\lambdabox$-terms, written in a monadic style.
We also describe $\reflect M$ as a \emph{reflection} of the term $M$ into an introspective Kripke model.

Let $w$ be a world of $\M$.  
Then, given a modal environment $\delta$ of types $\Delta$ at $w$ and an environment $\gamma$ of types $\Gamma$ at $w$, evaluation consumes a term of type $A$ under the context $\Delta; \Gamma$ and produces a value continuation of type $A$ at $w$.

For modal variables \eqref{reflect.mvar} and variables \eqref{reflect.var}, we look up the index $i$ in the semantic projection of $\delta$ and in $\gamma$, respectively.

For function abstraction \eqref{reflect.lam}, we first suppose that we can access via $\xi$ some world at which the value continuation $k$ represents the function argument.
Then, we evaluate the function body $M$ in an environment obtained by relocating the current environment via $\xi$ and extending it with $k$.

For function application \eqref{reflect.app}, we start by evaluating the function $\D$ in the current environment, obtaining a value $f$ at some world accessible via $\xi$.
By definition, the value of a function of type $A \imp B$ is a meta-level function that, given a value continuation of $A$ at some accessible world, returns a value continuation of $B$ at the same world.
Evaluating the function argument $\E$ in the current environment relocated via $\xi$ gives us a value continuation, which we use to call $f$.

Normalisation-by-evaluation is also known as \emph{reduction-free normalisation} \cite{AltenkirchHS1995,Danvy2005}, because performing substitution at the meta level frees us from having to implement it at the object level.
However, in the case of quotation \eqref{reflect.quo}, object-level modal substitution \eqref{msub} is required.

XXX


\section{Completeness}

\begin{definition}
  \label{Mu}
  \emph{A universal model for the $\lambdabox$-calculus.}
  \begin{gather*}
    \Mu \,=\, \langle\,\Cx,\,\Vu,\,\binop{\geqZ},\,\ideZ,\,\binop{\compeZ},\,\rennmZ,\,\id,\,\id\,\rangle\\[0.5\baselineskip]
    \Delta; \Gamma \Vu x \,=\, \Delta; \Gamma \enm \mkern-4mu \base
  \end{gather*}
\end{definition}

\begin{lemma}
  \label{reflectu/reifyu}
  Soundness and completeness of the $\lambdabox$-calculus with respect to the universal model $\Mu$.
  \begin{gather*}
    \tyrule{\reflectu}{\Delta; \Gamma \ent A}{\Mu\,|\,\Delta; \Gamma \eek A}\qquad
    \tyrule{\reifyu}{\Mu\,|\,\Delta; \Gamma \eek A}{\Delta; \Gamma \enm A}
  \end{gather*}
  \begin{proof}
    \normalshape
    By mutual induction on the type.
    \begin{alignat}{2}
      & \reflectu\, \{\base\}    \,&&\D \,=\, \return\, (\nt \D)\\
      & \reflectu\, \{A \imp B\} \,&&\D \,=\, \return\, (\eta\, k \mapsto \reflectu\, (\renntZ \eta\, \D \app \reifyu k))\\
      & \reflectu\, \{\sq A\}    \,&&\D \,=\, \eta\, f \mapsto \unq{\renntZ \eta\, \D}\, (f\, (\mwkZ \ideZ)\, (\mvO,\, \reflectu \mvO))\\[0.5\baselineskip]
      & \reifyu\,   \{\base\}    \,&& k \,=\, k \ideZ\, (\eta\ \D \mapsto \D)\\
      & \reifyu\,   \{A \imp B\} \,&& k \,=\, k \ideZ\, (\eta\, f \mapsto \lam\, (\reifyu\, (f\ (\wkZ \ideZ)\, (\reflectu \vO))))\\
      & \reifyu\,   \{\sq A\}    \,&& k \,=\, k \ideZ\, (\eta\, p \mapsto \quo{\syn p})
    \end{alignat}
  \end{proof}
\end{lemma}

\begin{lemma}
  \label{mide/ide}
  \normalshape
  \emph{Identity environments.}
  \begin{gather*}
    \mide : \Delta; \Gamma \eejks \Delta\qquad
    \ide : \Delta; \Gamma \eeks \Gamma
  \end{gather*}
  \normalshape
  Each proved by induction on the environment.
\end{lemma}

\begin{theorem}[Completeness]
  \label{reify}
  \begin{gather*}
    \tyrule{\reify}{\Delta; \Gamma \eeq A}{\Delta; \Gamma \enm A}
  \end{gather*}
  \begin{proof}
    \normalshape
    By lemma \ref{reflectu/reifyu} and \ref{mide/ide}.
    \begin{gather*}
      \reify f \,=\, \reifyu\, (f \mide \ide)
    \end{gather*}
  \end{proof}
\end{theorem}

\begin{corollary}[Normalisation]
  \label{nm}
  \begin{gather*}
    \tyrule{\nm}{\Delta; \Gamma \e A}{\Delta; \Gamma \enm A}
  \end{gather*}
  \begin{proof}
    \normalshape
    By theorem \ref{reflect} and \ref{reify}.
    \begin{gather*}
      \nm \,=\, \reify \comp \reflect
    \end{gather*}
  \end{proof}
\end{corollary}


\lipsum[1-5]


\section{Conclusion}

\lipsum[1-5]


%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.%.


\section*{Acknowledgements}

The author is deeply grateful to Andreas Abel, Guillaume Allais, Ahmad Salim Al-Sibahi, Roy Dyckhoff, Michael Gabbay, Paolo Giarrusso, Tom Jack, Roman Kireev, Jerzy Marcinkowski, Darryl McAdams, Conor McBride, Dominic Orchard, Maciej Pir\'{o}g, Ida Szubert, Tarmo Uustalu, Andrea Vezzosi, and Tomasz Wierzbicki, for many fruitful discussions over the years.

Furthermore, the author thanks Sergei Artemov, Andrej Bauer, Jacques Carette, Danko Ilik, Alex Kavvos, Jon Sterling, and the anonymous reviewers, for comments that helped improve this work.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% TODO: Remove this!
\paragraph{Citations}

Abel (2013) \cite{Abel2013}.
Alechina \emph{et~al.} (2001) \cite{AlechinaMPR2001}.
Altenkirch (1993) \cite{Altenkirch1993}.
Altenkirch, Hofmann, and Streicher (1995) \cite{AltenkirchHS1995}.
Altenkirch and Reus (1999) \cite{AltenkirchR1999}.
Artemov (2001) \cite{Artemov2001}.
Artemov and Bonelli (2007) \cite{ArtemovB2007}.
Bauer (2016) \cite{Bauer2016}.
Berger and Schwichtenberg (1991) \cite{BergerS1991}.
Bierman and de~Paiva (2000) \cite{BiermanP2000}.
Boolos (1994) \cite{Boolos1994}.
Bo\v{z}i\'{c} and Do\v{s}en (1984) \cite{BozicD1984}.
Brown and Palsberg (2016) \cite{BrownP2016}.
Chapman (2009) \cite{Chapman2009}.
C.~Coquand (1993) \cite{Coquand1993}.
C.~Coquand (2002) \cite{Coquand2002}.
T.~Coquand and Dybjer (1997) \cite{CoquandD1997}.
Danvy (1996) \cite{Danvy1996}.
Danvy (2005) \cite{Danvy2005}.
Danvy, Keller, and Puech (2014) \cite{DanvyKP2014}.
Davies and Pfenning (2001) \cite{DaviesP2001}.
de~Bruijn (1972) \cite{DeBruijn1972}.
Dybjer and Filinski (2002) \cite{DybjerF2002}.
Dyckhoff (2016) \cite{Dyckhoff2016}.
Ewald (1986) \cite{Ewald1986}.
Fischer Servi (1984) \cite{FischerServi1984}.
Fitting (2005) \cite{Fitting2005}.
Gabbay and Nanevski (2013) \cite{GabbayN2013}.
Girard \emph{et~al.} (1989) \cite{GirardTL1989}.
G\"{o}del (1933) \cite{Goedel1933}.
Iemhoff (2001) \cite{Iemhoff2001}.
Ilik (2010) \cite{Ilik2010}.
Ilik (2013) \cite{Ilik2013}.
Joachimski and Matthes (2003) \cite{JoachimskiM2003}.
Kovacs (2017) \cite{Kovacs2017}.
Kripke (1965) \cite{Kripke1965}.
Lindley (2005) \cite{Lindley2005}.
Martin-L\"{o}f (1975) \cite{MartinLoef1975}.
McBride (2005) \cite{McBride2005}.
McCarthy \emph{et~al.} (1962) \cite{McCarthyAEHL1962}.
McKinsey and Tarski (1948) \cite{McKinseyT1948}.
Meyer and Wand (1985) \cite{MeyerW1985}.
Mkrtychev (1997) \cite{Mkrtychev1997}.
Nanevski (2002) \cite{Nanevski2002}.
Nanevski (2004) \cite{Nanevski2004}.
Nanevski, Pfenning, and Pientka (2008) \cite{NanevskiPP2008}.
Norell (2007) \cite{Norell2007}.
Ono (1977) \cite{Ono1977}.
Pfenning and Davies (2001) \cite{PfenningD2001}.
Pientka and Abel (2015) \cite{PientkaA2015}.
Plotkin and Stirling (1986) \cite{PlotkinS1986}.
Sheard (2001) \cite{Sheard2001}.
Simpson (1994) \cite{Simpson1994}.
Stump (2016) \cite{Stump2016}.
Turner (2004) \cite{Turner2004}.
Wadler (2015) \cite{Wadler2015}.
Wickline, Lee, and Pfenning (1998) \cite{WicklineLP1998}.
Wijesekera (1990) \cite{Wijesekera1990}.


\bibliographystyle{entcs}
\bibliography{imla2017}

\end{document}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

